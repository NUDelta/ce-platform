import { Meteor } from "meteor/meteor";

import { Submissions } from "../OCEManager/currentNeeds";

import { addContribution } from '../OCEManager/OCEs/methods';
import {Detectors} from "../UserMonitor/detectors/detectors";
import {notify, notifyUsersInIncident, notifyUsersInNeed} from "../OpportunisticCoordinator/server/noticationMethods";
import {Incidents} from "../OCEManager/OCEs/experiences";
import {Schema} from "../schema";
import {serverLog} from "../logs";
import { log } from "util";

let LOCATIONS = {
  'park': {
    lat: 42.056838,
    lng: -87.675940
  },
  'lakefill': {
    lat: 42.054902,
    lng: -87.670197
  },
  'burgers': {
    lat: 42.046131,
    lng: -87.681559
  },
  'grocery': {
    lat: 42.047621,
    lng: -87.679488
  },
  'sushi': { // sashimi sashimi near whole foods
    lat: 42.048068,
    lng: -87.6811262
  },
  'grocery2': {
    lat: 42.039818,
    lng: -87.680088
  }
};

let USERS = {
  meg: {
    username: 'meg',
    email: 'meg@email.com',
    password: 'password',
    profile: {
      firstName: 'Meg',
      lastName: 'Grasse'
    }
  },
  andrew: {
    username: 'andrew',
    email: 'andrew@email.com',
    password: 'password',
    profile: {
      firstName: 'Andrew',
      lastName: 'Finke'
    }
  },
  josh: {
    username: 'josh',
    email: 'josh@email.com',
    password: 'password',
    profile: {
      firstName: 'Josh',
      lastName: 'Shi'
    }
  }
};

let DETECTORS = {
  night: {
    _id: 'Wth3TB9Lcf6me6vgy',
    description: 'places where it\'s nighttime,',
    variables: ['var nighttime;'],
    rules: ['(nighttime);']
  },
  daytime: {
    _id: 'tyZMZvPKkkSPR4FpG',
    description: 'places where it\'s daytime,',
    variables: ['var daytime;'],
    rules: ['daytime;']
  },
  coffee: {
    _id: 'saxQsfSaBiHHoSEYK',
    description: 'coffee',
    variables: ['var coffeeroasteries;',
      'var coffee;',
      'var cafes;',
      'var coffeeshops;',
      'var coffeeteasupplies;'
    ],
    rules: ['(coffeeroasteries || coffee) || ((coffeeshops || coffeeteasupplies) || cafes);']
  },
  train: {
    _id: '2wH5bFr77ceho5BgF',
    description: 'trains',
    variables: ['var publictransport;', 'var trainstations;', 'var trains;'],
    rules: ['(trainstations || trains) || publictransport;']
  },
  rainy: {
    _id: 'puLHKiGkLCJWpKc62',
    description: 'rainy',
    variables: ['var rain;'],
    rules: ['(rain);']
  },
  sunny: {
    _id: '6vyrBtdDAyRArMasj',
    description: 'clear',
    variables: ['var clear;', 'var daytime;'],
    rules: ['(clear && daytime);']
  },
  cloudy: {
    _id: 'sorCvK53fyi5orAmj',
    description: 'clouds',
    variables: ['var clouds;', 'var daytime;'],
    rules: ['(clouds && daytime);']
  },
  hour0: {
    _id: "v2ANTJr1I7wle3Ek8",
    description: "during 00:00",
    variables: ["var hour;"],
    rules: ["hour == 0"]
  }
};

export const getDetectorId = (detector) => {
  let db_detector = Detectors.findOne({description: detector.description});
  if (db_detector) {
    console.log('getting db detector for', detector.description, 'which is', db_detector._id);
    console.log(db_detector)
    return db_detector._id;
  } else {
    console.log('getting detector for', detector.description, 'which is', detector._id);

    return detector._id;
  }
};

Meteor.methods({
  getDetectorId({name}) {
    new SimpleSchema({
      name: { type: String }
    }).validate({name});

    if (!(name in CONSTANTS.DETECTORS)) {
      throw new Meteor.Error('getDetectorId.keynotfound',
        `Detector by the name '${name}' was not found in CONSTANTS.DETECTORS`);
    }
  }
});

// this is the code that will eventually be generated by the CN compiler!
const createMurderMystery = function() {
  let values = [
    'not busy at all',
    'a little busy',
    'somewhat busy',
    'pretty busy',
    'very busy'
  ];
  // console.log(DETECTORS);
  /*
  let places = ["coffee", "coffee", "coffee", "coffee", "coffee",];
  let detectorIds = places.map((x) => { return Random.id(); });
  let detectorNames = [];
  */
  let dropdownText = [
    'not busy at all',
    'a little busy',
    'somewhat busy',
    'pretty busy',
    'very busy'
  ];
  /*
  let questions = [
    "How busy is the coffee shop right now?",
    "Name an interesting option on the menu",
    "What did you order?"
  ]
  */
  let question1 = "How busy is the coffee shop right now?"
  let question2 = "Name an interesting option on the menu"
  let question3 = "What did you order?"

  let DROPDOWN_OPTIONS = _.zip(dropdownText);

  const MurderMysteryCallback = function (sub) {
    let submissions = Submissions.find({
      iid: sub.iid,
      needName: sub.needName
    }).fetch();
    
    let participants = submissions.map((submission) => { return submission.uid; });
    
    notify(participants, sub.iid, 'See images from your group bumped experience!', '', '/apicustomresults/' + sub.iid + '/' + sub.eid);
    
  }
  
  let experience = {
    name: 'Murder Mystery',
    participateTemplate: 'murderMysteryInitial',
    resultsTemplate: 'murderMysteryResults',
    contributionTypes: [],
    description: "You've been invited to participate in a murder mystery!",
    notificationText: "You've been invited to participate in a murder mystery!",
    callbacks: []
  };


  const staticAffordances = ['cn'];
  const places = [
    ["coffee", "at a coffee shop", "Please help us build the story by answering some initial questions about your situation!"],
  ];
  
  // const needs = places.map(place => {
  //   const [detectorName, situationDescription, instruction] = place;
  //   return {
  //     needName: `Bumped Three ${detectorName}`,
  //     situation: {
  //       detector: getDetectorId(DETECTORS[detectorName]),
  //       number: '1'
  //     },
  //     toPass: {
  //       situationDescription: `Having a good time ${situationDescription}?`,
  //       instruction: `${instruction}`
  //     },
  //     numberNeeded: 3,
  //     // notificationDelay: 90 uncomment for testing
  //   }
  // });
  
  
  staticAffordances.forEach(participant => {
    experience.contributionTypes = [...experience.contributionTypes, ...addStaticAffordanceToNeeds(participant, ((places) => 
      places.map(place => {
        const [detectorName, situationDescription, instruction] = place;
        return {
          needName: `Murder Mystery ${detectorName}`,
          situation: {
            detector: getDetectorId(DETECTORS[detectorName]),
            number: 3
          },
          toPass: {
            situationDescription: `Having a good time ${situationDescription}?`,
            instruction: `${instruction}`,
            question1: `${question1}`,
            question2: `${question2}`,
            question3: `${question3}`,
            dropdownChoices: {
              name: values,
              options: DROPDOWN_OPTIONS
            }
          },
          numberNeeded: 3,
          // notificationDelay: 90 uncomment for testing
        }
      })
    )(places))];
  });
  
  return experience;
}


/**
 * Side effect: Changes the global DETECTORS object, adding another detector with key "detectorKey_staticAffordance"
 *
 * @param staticAffordance
 * @param detectorKey
 * @returns newDetectorKey
 */
const addStaticAffordanceToDetector = function(staticAffordance, detectorKey) {
  let newVars = JSON.parse(JSON.stringify(DETECTORS[detectorKey]['variables']));
  newVars.push(`var ${staticAffordance};`);
  let newRules = JSON.parse(JSON.stringify(DETECTORS[detectorKey]['rules']));
  // modify last detector rule
  // when rules has a flat structure where rules.length == 1, last rule is the predicate
  // i.e. ['(diners || restaurants || cafeteria || food_court);']
  // when rules have a nested structure where rules.length > 1, last rule is the predicate
  // i.e. ['worship_places = (buddhist_temples || churches);', '(worship_places || landmarks);']
  let lastRule = newRules.pop();
  // each rule has a `;` at end, i.e. (rain && park);
  // in order to modify the rule, must add predicate preceding the rule
  let lastRuleNoSemicolon = lastRule.split(';')[0];
  lastRule = `(${staticAffordance} && (${lastRuleNoSemicolon}));`;
  newRules.push(lastRule);

  let newDetectorKey = `${detectorKey}_${staticAffordance}`;
  // Change DETECTORS if newDetectorKey does not already exist (some experiences might have already created coffee_mechanismRich, for example)
  if (!(newDetectorKey in DETECTORS)) {
    DETECTORS[newDetectorKey] = {
      '_id': Random.id(),
      'description': `${DETECTORS[detectorKey].description} ${staticAffordance}`,
      'variables': newVars,
      'rules': newRules
    };
  }
  console.log( DETECTORS[newDetectorKey].description,  DETECTORS[newDetectorKey]._id);
  return newDetectorKey;
};

/**
 *
 * @param staticAffordances [String] the affordance to add
 *        i.e. 'mechanismRich'
 * @param contributionTypes [Array] list of all the needs by which to modify
 * @return
 */
const addStaticAffordanceToNeeds = function(staticAffordance, contributionTypes) {
  return _.map(contributionTypes, (need) => {
    let detectorKey;
    _.forEach(_.keys(DETECTORS), (key) => {
      if (DETECTORS[key]._id === need.situation.detector) {
        detectorKey = key;
      }
    });
    // WILL THROW ERROR if we don't find the matching detector id

    let newDetectorKey = addStaticAffordanceToDetector(staticAffordance, detectorKey);
    need.situation.detector = DETECTORS[newDetectorKey]._id;
    console.log('adding to need', newDetectorKey, DETECTORS[newDetectorKey]._id);
    return need;
  });
};

/**
 *
 * @param contributionTypes
 * @param triggerTemplate [String] should be written as a string, with ES6 templating syntax
 *        i.e. "cb.newSubmission(\"${need.needName}\")"
 *        If using templating syntax, you have access to the each individual need object
 * @param sendNotificationFn
 */
const notifCbForMultiNeeds = function(contributionTypes, triggerTemplate, sendNotificationFn) {
  return contributionTypes.map((need) => {
    return {
      trigger: eval('`' + triggerTemplate + '`'),
      function: sendNotificationFn.toString()
    };
  });
};

let EXPERIENCES = {
  murder: createMurderMystery()
  };

export const CONSTANTS = {
  'LOCATIONS': LOCATIONS,
  'USERS': USERS,
  // Comment out if you would like to only test specific experiences
  // 'EXPERIENCES': (({ halfhalfEmbodiedMimicry }) => ({ halfhalfEmbodiedMimicry }))(EXPERIENCES),
  'EXPERIENCES': EXPERIENCES,
  // 'EXPERIENCES': TRIADIC_EXPERIENCES,
  'DETECTORS': DETECTORS
};
